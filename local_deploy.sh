#!/bin/bash

#                             ___  _________ 
#                            / _ \/_  __/ _ \
#                           / // / / / / , _/
#                          /____/ /_/ /_/|_| 
#
#            __                 __  ___           __         
#           / /  ___  _______ _/ / / _ \___ ___  / /__  __ __
#          / /__/ _ \/ __/ _ `/ / / // / -_) _ \/ / _ \/ // /
#         /____/\___/\__/\_,_/_/ /____/\__/ .__/_/\___/\_, / 
#                                        /_/          /___/  
#
# Create or restart a local Boot2Docker VM to install Docker Trusted Registry

set -e

MACHINE_NAME='dtr-local'
MACHINE_DRIVER='virtualbox'

# Create a local VM for DTR if it does not already exist.
MACHINE_STATUS="$(docker-machine status $MACHINE_NAME || true)"
if [[ -z "$MACHINE_STATUS" || "$MACHINE_STATUS" == "error getting state for host dtr-local: machine does not exist" ]]; then
	echo "Creating the VM..."
	docker-machine create \
	--driver "$MACHINE_DRIVER" \
	--virtualbox-boot2docker-url integration/boot2docker-1.10.1.iso \
	--virtualbox-cpu-count 2 \
	--virtualbox-memory 2048 \
	"$MACHINE_NAME"

	MACHINE_STATUS="$(docker-machine status $MACHINE_NAME)"
fi

# Stop the VM so that we can prepare shared folders.
if [ "$MACHINE_STATUS" != "Stopped" ]; then
	echo "Stopping VM..."
	docker-machine stop "$MACHINE_NAME"
fi

# The shared folder path will be the directory this script lives in which
# should be the root of the dhe-deploy repo.
SHARED_FOLDER_NAME="dtr-host-share"
SHARED_FOLDER_HOST_PATH="$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )"

echo "Setting up Virtualbox Shared Folder from host OS..."
SF_CREATE_OUTPUT=$(VBoxManage sharedfolder add "$MACHINE_NAME" --name "$SHARED_FOLDER_NAME" --hostpath "$SHARED_FOLDER_HOST_PATH" 2>&1 || true)
if [[ "$SF_CREATE_OUTPUT" == *"already exists"* ]]; then
	echo "Shared folder $SHARED_FOLDER_NAME already exists."
elif [ "$SF_CREATE_OUTPUT" != "" ]; then
	echo "Error trying to create shared folder: $SF_CREATE_OUTPUT"
	exit 1
fi

# Start the VM.
docker-machine start "$MACHINE_NAME"

echo "Mounting shared volume in VM..."
docker-machine ssh "$MACHINE_NAME" "sudo sh" << EOF
	mkdir -p $SHARED_FOLDER_HOST_PATH
	mount -t vboxsf $SHARED_FOLDER_NAME $SHARED_FOLDER_HOST_PATH
EOF

# Evaluate the docker-machine env to get the client setup.
echo "Switching to use $MACHINE_NAME Docker daemon..."
docker-machine env $MACHINE_NAME --shell bash
eval "$(docker-machine env $MACHINE_NAME --shell bash)"

# Force a build of the images (may be fast if the build steps are cache hits)
# by removing files generated by the Makefiles for each container.
forceBuild() {
	BUILDFILES="manager/.managerContainer
			    adminserver/.adminserverContainer
			    logaggregator/.logAggregatorContainer
			    garant/.garantContainer
			    nginx/.nginxContainer
			    registryindex/.registryIndexContainer"
	for buildfile in $BUILDFILES;
	do
		if [ -f "$buildfile" ];
		then
			rm "$buildfile"
		fi
	done
}

# Build all of the images using the developer's Docker engine and export them
# for use with the integration test VM.
echo "Making DTR images in VM (this may take a while)..."
forceBuild
make

# Cleanup the container marker files so that Make is not confused about where
# the containers were built.
forceBuild

echo "Cleaning up containers in VM..."
docker-machine ssh "$MACHINE_NAME" 'docker ps -aq | xargs -r docker rm -f'

echo "Cleaning up Docker logs in VM..."
docker-machine ssh "$MACHINE_NAME" "sudo sh -c '> /var/lib/boot2docker/docker.log'"

echo "Cleaning up DTR state..."
docker-machine ssh "$MACHINE_NAME" "sudo sh" << EOF
	if [ -e /mnt/sda1/dtr ];
	then
		rm -rf /mnt/sda1/dtr
	fi

	mkdir -p /mnt/sda1/dtr/config /mnt/sda1/dtr/data /usr/local/etc/dtr	/var/local/dtr

	# Note: We bind mount these because the tmpfs that boot2docker uses appears
	# to have some consistency issues. This is also why we can't symlink the
	# directory.
	mount -o bind /mnt/sda1/dtr/config /usr/local/etc/dtr
	mount -o bind /mnt/sda1/dtr/data /var/local/dtr
EOF

echo "Cleaning up Docker networking state"
docker-machine ssh "$MACHINE_NAME" "sudo sh" << 'EOF'
	set -e
	echo "stopping docker daemon..."
	kill $(pgrep -f /usr/local/bin/docker) || true
	echo "removing network dir"
	rm -rf /var/lib/docker/network
	echo "starting docker daemon"
	/etc/init.d/docker start
	echo "waiting .."
	sleep 2
EOF

docker-machine ssh "$MACHINE_NAME" 'docker ps'

# Install DTR.
echo "Installing DTR in VM..."
docker-machine ssh "$MACHINE_NAME" 'docker run dockerhubenterprise/trusted-registry-dev install | sh'

# Wait a bit for all of the containers to chillax.
echo "Waiting for things to simmer down (10 seconds)"
for i in {1..10};
do
	printf '.'
	sleep 1
done
printf '\n'

# The machine directory will contain the Docker client certs and SSH key.
MACHINE_DIR="$HOME/.docker/machine/machines/$MACHINE_NAME"

# Copy the private key for the Docker Machine into the integration directory.
cp "$MACHINE_DIR/id_rsa" ./integration/id_rsa

export DTR_HOST=$(docker-machine ip dtr-local)

# Run the integration test suites.
export SSH_USERNAME=docker
export SSH_PRIVATE_KEY_PATH=/go/src/github.com/docker/dhe-deploy/integration/id_rsa
export SSH_PASSWORD=''

make test-integration
