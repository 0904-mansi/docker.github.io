package openid

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"github.com/docker/orca/enzi/jose"
	"github.com/satori/go.uuid"
)

// Client is used to access API endpoints on an OpenID Connect Provider.
type Client struct {
	httpClient        *http.Client
	signingKey        *jose.PrivateKey
	id                string
	redirectURI       string
	providerAddr      string
	authorizationPath string
	tokenPath         string
	certChain         []string
}

// NewClient returns a new client for accessing API endpoints on an OpenID
// Connect Provider. The client will use the given httpClient to make requests
// to the given providerAddr, you must ensure that the given httpClient has the
// propper TLS configuration to verify connections to the providerAddr. The
// given signing key is used to generate authentication credentials when
// requesting tokens from the provider. The id and redirectURI are the ID and
// redirect URI of this service as registered with the OpenID Connect Provider.
// providerAddr is the hostname[:port] for the OpenID Connect Provider.
// authorizationPath and tokenPath are the paths of the authorization endpoint
// and token endpoints, respectively, on the provider. If keyCertChain is
// specified, it should be one or more PEM-encoded certificates for the
// signing key. In this case, all authentication JWTs generated by this client
// will use an 'x5c' header instead of 'kid' for the provider to verify. The
// first certificate in the bundle must have the signing key as its subject,
// and the bundle must be able to chain up to a root certificate that this
// service has registered with the provider.
func NewClient(httpClient *http.Client, signingKey *jose.PrivateKey, id, redirectURI, providerAddr, authorizationPath, tokenPath string, keyCertChain ...string) *Client {
	return &Client{
		httpClient:        httpClient,
		signingKey:        signingKey,
		id:                id,
		redirectURI:       redirectURI,
		providerAddr:      providerAddr,
		authorizationPath: authorizationPath,
		tokenPath:         tokenPath,
		certChain:         keyCertChain,
	}
}

// PrepareAuthorizationRequest creates an authorization request URL with the
// appropriate request parameters including an encoded state parameter which is
// HMAC'ed with the returned redirectStateKey. The given redirectNext should be
// the URL of the page the User-Agent should visit after the authorization
// process is complete.
func (client *Client) PrepareAuthorizationRequest(redirectNext string) (authorizeURL, redirectStateKey string) {
	params := url.Values{}
	params.Set("client_id", client.id)
	params.Set("redirect_uri", client.redirectURI)
	params.Set("scope", "openid")
	params.Set("response_type", "code")

	// Encoded and signed redirect state for CSRF protection.
	redirectState := RedirectState{
		RedirectNext: redirectNext,
		RedirectURI:  client.redirectURI,
	}

	redirectStateKey = uuid.NewV4().String()

	params.Set("state", redirectState.Encode(redirectStateKey))

	authorizeURL = (&url.URL{
		Scheme:   "https",
		Host:     client.providerAddr,
		Path:     client.authorizationPath,
		RawQuery: params.Encode(),
	}).String()

	return authorizeURL, redirectStateKey
}

// GetTokenWithAuthorizationCode requests a token using the given
// authorizationCode and redirectState. If there is an oauth error response
// then the returned error will be of the type
// *(github.com/docker/orca/enzi/api/client/openid/oautherrors).ErrorResponse
func (client *Client) GetTokenWithAuthorizationCode(authorizationCode string, redirectState *RedirectState, linkSession bool) (*TokenResponse, error) {
	// Prepare a token request using the "authorization_code" grant type.
	params := url.Values{}
	params.Set("grant_type", "authorization_code")
	params.Set("code", authorizationCode)
	params.Set("redirect_uri", redirectState.RedirectURI)
	params.Set("link_session", strconv.FormatBool(linkSession))

	return client.requestToken(params)
}

// GetTokenWithUsernamePasword requests a token using the given username and
// password. This method is meant only for clients which represents highly
// privileged applications. If linkSession is true, a valid token response will
// contain session information which the application can later use with the
// RootSession method while the session is still valid. If there is an oauth
// error response then the returned error will be of the type
// *(github.com/docker/orca/enzi/api/client/openid/oautherrors).ErrorResponse
func (client *Client) GetTokenWithUsernamePasword(username, password string, linkSession bool) (*TokenResponse, error) {
	// Prepare a token request using the "password" grant type.
	params := url.Values{}
	params.Set("grant_type", "password")
	params.Set("username", username)
	params.Set("password", password)
	params.Set("link_session", strconv.FormatBool(linkSession))

	return client.requestToken(params)
}

// GetTokenWithRootSession requests a token using the given root sessionSecret.
// This method is meant only or clients which represent highly privileged
// applications. If there is an oauth error response then the returned error
// will be of the type
// *(github.com/docker/orca/enzi/api/client/openid/oautherrors).ErrorResponse
func (client *Client) GetTokenWithRootSession(sessionSecret string) (*TokenResponse, error) {
	// Prepare a token request using the "root_session" grant type.
	params := url.Values{}
	params.Set("grant_type", "root_session")
	params.Set("session_secret", sessionSecret)

	return client.requestToken(params)
}

// GetTokenWithServiceSession requests a token using the given service
// sessionSecret. If there is an oauth error response then the returned error
// will be of the type
// *(github.com/docker/orca/enzi/api/client/openid/oautherrors).ErrorResponse
func (client *Client) GetTokenWithServiceSession(sessionSecret string) (*TokenResponse, error) {
	// Prepare a token request using the "service_session" grant type.
	params := url.Values{}
	params.Set("grant_type", "service_session")
	params.Set("session_secret", sessionSecret)

	return client.requestToken(params)
}

// GetTokenWithRefreshToken requests a token using the given refreshToken. The
// refreshToken should still be valid as long as the client application still
// has authorization by the account or is implicitly authorized (privileged).
// If there is an oauth error response then the returned error will be of the
// type
// *(github.com/docker/orca/enzi/api/client/openid/oautherrors).ErrorResponse
func (client *Client) GetTokenWithRefreshToken(refreshToken string) (*TokenResponse, error) {
	// Prepare a token request using the "refresh_token" grant type.
	params := url.Values{}
	params.Set("grant_type", "refresh_token")
	params.Set("refresh_token", refreshToken)

	return client.requestToken(params)
}

// requestToken makes a POST request to get a Token using the given form
// parameters.
func (client *Client) requestToken(params url.Values) (*TokenResponse, error) {
	authenticationToken, err := client.makeAuthenticationToken()
	if err != nil {
		return nil, fmt.Errorf("unable to make authentication token: %s", err)
	}

	// Add OpenID Connect Client Authentication parameters.
	params.Set("client_assertion_type", "urn:ietf:params:oauth:client-assertion-type:jwt-bearer")
	params.Set("client_assertion", authenticationToken)

	tokenURL := (&url.URL{
		Scheme: "https",
		Host:   client.providerAddr,
		Path:   client.tokenPath,
	}).String()

	resp, err := client.httpClient.PostForm(tokenURL, params)
	if err != nil {
		return nil, fmt.Errorf("http client error: %s", err)
	}

	defer resp.Body.Close()

	// Expect either 200 or 400 responses.
	if !(resp.StatusCode == http.StatusOK || resp.StatusCode == http.StatusBadRequest) {
		body, _ := ioutil.ReadAll(resp.Body)
		return nil, fmt.Errorf("unexpected response code from token endpoint: %d - %s", resp.StatusCode, string(body))
	}

	var tokenResponse TokenResponse
	if err := json.NewDecoder(resp.Body).Decode(&tokenResponse); err != nil {
		return nil, fmt.Errorf("unable to decode token response: %s", err)
	}

	if tokenResponse.ErrorResponse != nil {
		return nil, tokenResponse.ErrorResponse
	}

	return &tokenResponse, nil
}

// makeAuthenticationToken generates and returns an authentication JWT which
// is used to authenticate to the OpenID Connect Provider's token endpoint.
func (client *Client) makeAuthenticationToken() (string, error) {
	signer, err := client.signingKey.Signer()
	if err != nil {
		return "", fmt.Errorf("unable to initialize JWT signer: %s", err)
	}

	header := map[string]interface{}{
		"typ": "JWT",
		"alg": signer.Name(),
	}

	if len(client.certChain) > 0 {
		// The provider will be able to verify the signature and chain
		// it to the pre-registered root bundle. There's no need for a
		// callback to a registered endpoint, but the token header does
		// become significantly larger.
		header["x5c"] = client.certChain
	} else {
		// The provider will be able to use our pre-registered JWKs URI
		// to fetch and cache the corresponding public key to verify
		// our signature.
		header["kid"] = client.signingKey.ID
	}

	claims := map[string]interface{}{
		"iss": client.id,
		"sub": client.id,
		"aud": []string{client.providerAddr},
		"exp": time.Now().Add(time.Minute).Unix(),
	}

	headerBytes, err := json.Marshal(header)
	if err != nil {
		return "", fmt.Errorf("unable to encode JWT header: %s", err)
	}

	claimsBytes, err := json.Marshal(claims)
	if err != nil {
		return "", fmt.Errorf("unable to encode JWT claims: %s", err)
	}

	signingInput := fmt.Sprintf("%s.%s", jose.Base64URLEncode(headerBytes), jose.Base64URLEncode(claimsBytes))
	signature, err := signer.Sign(strings.NewReader(signingInput))
	if err != nil {
		return "", fmt.Errorf("unable to sign JWT: %s", err)
	}

	return fmt.Sprintf("%s.%s", signingInput, signature), nil
}
